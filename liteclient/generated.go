package liteclient

// Code autogenerated. DO NOT EDIT.

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"github.com/startfellows/tongo/tl"
	"io"
)

type AdnlMessage struct {
	tl.SumType
	AdnlMessageQuery struct {
		QueryId tl.Int256
		Query   []byte
	}
	AdnlMessageAnswer struct {
		QueryId tl.Int256
		Answer  []byte
	}
}

func (t AdnlMessage) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "AdnlMessageQuery":
		b, err = tl.Marshal(uint32(0xb48bf97a))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageQuery.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageQuery.Query)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "AdnlMessageAnswer":
		b, err = tl.Marshal(uint32(0xfac8416))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.AdnlMessageAnswer.Answer)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *AdnlMessage) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xb48bf97a:
		t.SumType = "AdnlMessageQuery"
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageQuery.Query)
		if err != nil {
			return err
		}
	case 0xfac8416:
		t.SumType = "AdnlMessageAnswer"
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.QueryId)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.AdnlMessageAnswer.Answer)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerAccountId struct {
	Workchain uint32
	Id        tl.Int256
}

func (t LiteServerAccountId) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountId) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAccountState struct {
	Id         TonNodeBlockIdExt
	Shardblk   TonNodeBlockIdExt
	ShardProof []byte
	Proof      []byte
	State      []byte
}

func (t LiteServerAccountState) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.State)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAccountState) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.State)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerAllShardsInfo struct {
	Id    TonNodeBlockIdExt
	Proof []byte
	Data  []byte
}

func (t LiteServerAllShardsInfo) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerAllShardsInfo) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockData struct {
	Id   TonNodeBlockIdExt
	Data []byte
}

func (t LiteServerBlockData) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockData) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockHeader struct {
	Id          TonNodeBlockIdExt
	Mode        uint32
	HeaderProof []byte
}

func (t LiteServerBlockHeader) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.HeaderProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockHeader) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.HeaderProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockLink struct {
	tl.SumType
	LiteServerBlockLinkBack struct {
		ToKeyBlock bool
		From       TonNodeBlockIdExt
		To         TonNodeBlockIdExt
		DestProof  []byte
		Proof      []byte
		StateProof []byte
	}
	LiteServerBlockLinkForward struct {
		ToKeyBlock  bool
		From        TonNodeBlockIdExt
		To          TonNodeBlockIdExt
		DestProof   []byte
		ConfigProof []byte
		Signatures  LiteServerSignatureSet
	}
}

func (t LiteServerBlockLink) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	switch t.SumType {
	case "LiteServerBlockLinkBack":
		b, err = tl.Marshal(uint32(0xef7e1bef))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	case "LiteServerBlockLinkForward":
		b, err = tl.Marshal(uint32(0x520fce1c))
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.From)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.To)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
		b, err = tl.Marshal(t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	default:
		return nil, fmt.Errorf("invalid sum type")
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockLink) UnmarshalTL(r io.Reader) error {
	var err error
	var b [4]byte
	_, err = io.ReadFull(r, b[:])
	if err != nil {
		return err
	}
	tag := int(binary.LittleEndian.Uint32(b[:]))
	switch tag {
	case 0xef7e1bef:
		t.SumType = "LiteServerBlockLinkBack"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.Proof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkBack.StateProof)
		if err != nil {
			return err
		}
	case 0x520fce1c:
		t.SumType = "LiteServerBlockLinkForward"
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ToKeyBlock)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.From)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.To)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.DestProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.ConfigProof)
		if err != nil {
			return err
		}
		err = tl.Unmarshal(r, &t.LiteServerBlockLinkForward.Signatures)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf("invalid tag")
	}
	return nil
}

type LiteServerBlockState struct {
	Id       TonNodeBlockIdExt
	RootHash tl.Int256
	FileHash tl.Int256
	Data     []byte
}

func (t LiteServerBlockState) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockState) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerBlockTransactions struct {
	Id         TonNodeBlockIdExt
	ReqCount   uint32
	Incomplete bool
	Ids        []LiteServerTransactionId
	Proof      []byte
}

func (t LiteServerBlockTransactions) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ReqCount)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Incomplete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerBlockTransactions) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ReqCount)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Incomplete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerConfigInfo struct {
	Mode        uint32
	Id          TonNodeBlockIdExt
	StateProof  []byte
	ConfigProof []byte
}

func (t LiteServerConfigInfo) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ConfigProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerConfigInfo) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ConfigProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerCurrentTime struct {
	Now uint32
}

func (t LiteServerCurrentTime) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerCurrentTime) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerError struct {
	Code    uint32
	Message string
}

func (t LiteServerError) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Code)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Message)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerError) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Code)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Message)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryEntry struct {
	Hash tl.Int256
	Data []byte
}

func (t LiteServerLibraryEntry) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Data)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryEntry) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Hash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Data)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerLibraryResult struct {
	Result []LiteServerLibraryEntry
}

func (t LiteServerLibraryResult) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Result)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerLibraryResult) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Result)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfo struct {
	Last          TonNodeBlockIdExt
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExt
}

func (t LiteServerMasterchainInfo) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfo) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerMasterchainInfoExt struct {
	Mode          uint32
	Version       uint32
	Capabilities  uint64 `json:",string"`
	Last          TonNodeBlockIdExt
	LastUtime     uint32
	Now           uint32
	StateRootHash tl.Int256
	Init          TonNodeZeroStateIdExt
}

func (t LiteServerMasterchainInfoExt) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Last)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.LastUtime)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateRootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Init)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerMasterchainInfoExt) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Last)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.LastUtime)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateRootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Init)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerPartialBlockProof struct {
	Complete bool
	From     TonNodeBlockIdExt
	To       TonNodeBlockIdExt
	Steps    []LiteServerBlockLink
}

func (t LiteServerPartialBlockProof) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.From)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.To)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Steps)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerPartialBlockProof) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.From)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.To)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Steps)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerRunMethodResult struct {
	Mode       uint32
	Id         TonNodeBlockIdExt
	Shardblk   TonNodeBlockIdExt
	ShardProof []byte
	Proof      []byte
	StateProof []byte
	InitC7     []byte
	LibExtras  []byte
	ExitCode   uint32
	Result     []byte
}

func (t LiteServerRunMethodResult) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.ShardProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Proof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.StateProof)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>3)&1 == 1 {
		b, err = tl.Marshal(t.InitC7)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>4)&1 == 1 {
		b, err = tl.Marshal(t.LibExtras)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	b, err = tl.Marshal(t.ExitCode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Result)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerRunMethodResult) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempShardProof []byte
		err = tl.Unmarshal(r, &tempShardProof)
		if err != nil {
			return err
		}
		t.ShardProof = tempShardProof
	}
	if (t.Mode>>0)&1 == 1 {
		var tempProof []byte
		err = tl.Unmarshal(r, &tempProof)
		if err != nil {
			return err
		}
		t.Proof = tempProof
	}
	if (t.Mode>>1)&1 == 1 {
		var tempStateProof []byte
		err = tl.Unmarshal(r, &tempStateProof)
		if err != nil {
			return err
		}
		t.StateProof = tempStateProof
	}
	if (t.Mode>>3)&1 == 1 {
		var tempInitC7 []byte
		err = tl.Unmarshal(r, &tempInitC7)
		if err != nil {
			return err
		}
		t.InitC7 = tempInitC7
	}
	if (t.Mode>>4)&1 == 1 {
		var tempLibExtras []byte
		err = tl.Unmarshal(r, &tempLibExtras)
		if err != nil {
			return err
		}
		t.LibExtras = tempLibExtras
	}
	err = tl.Unmarshal(r, &t.ExitCode)
	if err != nil {
		return err
	}
	if (t.Mode>>2)&1 == 1 {
		var tempResult []byte
		err = tl.Unmarshal(r, &tempResult)
		if err != nil {
			return err
		}
		t.Result = tempResult
	}
	return nil
}

type LiteServerSendMsgStatus struct {
	Status uint32
}

func (t LiteServerSendMsgStatus) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Status)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSendMsgStatus) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Status)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockLink struct {
	Id    TonNodeBlockIdExt
	Proof []byte
}

func (t LiteServerShardBlockLink) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockLink) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardBlockProof struct {
	MasterchainId TonNodeBlockIdExt
	Links         []LiteServerShardBlockLink
}

func (t LiteServerShardBlockProof) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.MasterchainId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Links)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardBlockProof) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.MasterchainId)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Links)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerShardInfo struct {
	Id         TonNodeBlockIdExt
	Shardblk   TonNodeBlockIdExt
	ShardProof []byte
	ShardDescr []byte
}

func (t LiteServerShardInfo) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shardblk)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ShardDescr)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerShardInfo) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shardblk)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.ShardDescr)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignature struct {
	NodeIdShort tl.Int256
	Signature   []byte
}

func (t LiteServerSignature) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.NodeIdShort)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signature)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignature) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.NodeIdShort)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signature)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerSignatureSet struct {
	ValidatorSetHash uint32
	CatchainSeqno    uint32
	Signatures       []LiteServerSignature
}

func (t LiteServerSignatureSet) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.ValidatorSetHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.CatchainSeqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Signatures)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerSignatureSet) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.ValidatorSetHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.CatchainSeqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Signatures)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionId struct {
	Mode    uint32
	Account *tl.Int256
	Lt      *uint64 `json:",string"`
	Hash    *tl.Int256
}

func (t LiteServerTransactionId) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.Account)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Hash)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionId) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	if (t.Mode>>0)&1 == 1 {
		var tempAccount tl.Int256
		err = tl.Unmarshal(r, &tempAccount)
		if err != nil {
			return err
		}
		t.Account = &tempAccount
	}
	if (t.Mode>>1)&1 == 1 {
		var tempLt uint64
		err = tl.Unmarshal(r, &tempLt)
		if err != nil {
			return err
		}
		t.Lt = &tempLt
	}
	if (t.Mode>>2)&1 == 1 {
		var tempHash tl.Int256
		err = tl.Unmarshal(r, &tempHash)
		if err != nil {
			return err
		}
		t.Hash = &tempHash
	}
	return nil
}

type LiteServerTransactionId3 struct {
	Account tl.Int256
	Lt      uint64 `json:",string"`
}

func (t LiteServerTransactionId3) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionId3) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Account)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Lt)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionInfo struct {
	Id          TonNodeBlockIdExt
	Proof       []byte
	Transaction []byte
}

func (t LiteServerTransactionInfo) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Proof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transaction)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionInfo) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Proof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transaction)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerTransactionList struct {
	Ids          []TonNodeBlockIdExt
	Transactions []byte
}

func (t LiteServerTransactionList) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Ids)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Transactions)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerTransactionList) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Ids)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Transactions)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerValidatorStats struct {
	Mode       uint32
	Id         TonNodeBlockIdExt
	Count      uint32
	Complete   bool
	StateProof []byte
	DataProof  []byte
}

func (t LiteServerValidatorStats) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Complete)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.StateProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.DataProof)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerValidatorStats) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Id)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Count)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Complete)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.StateProof)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.DataProof)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerVersion struct {
	Mode         uint32
	Version      uint32
	Capabilities uint64 `json:",string"`
	Now          uint32
}

func (t LiteServerVersion) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Version)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Capabilities)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Now)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerVersion) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Mode)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Version)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Capabilities)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Now)
	if err != nil {
		return err
	}
	return nil
}

type LiteServerDebugVerbosity struct {
	Value uint32
}

func (t LiteServerDebugVerbosity) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Value)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *LiteServerDebugVerbosity) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Value)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeBlockId struct {
	Workchain int32
	Shard     uint64 `json:",string"`
	Seqno     uint32
}

func (t TonNodeBlockId) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockId) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeBlockIdExt struct {
	Workchain int32
	Shard     uint64 `json:",string"`
	Seqno     uint32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeBlockIdExt) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Seqno)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeBlockIdExt) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Shard)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.Seqno)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

type TonNodeZeroStateIdExt struct {
	Workchain uint32
	RootHash  tl.Int256
	FileHash  tl.Int256
}

func (t TonNodeZeroStateIdExt) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.RootHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.FileHash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (t *TonNodeZeroStateIdExt) UnmarshalTL(r io.Reader) error {
	var err error
	err = tl.Unmarshal(r, &t.Workchain)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.RootHash)
	if err != nil {
		return err
	}
	err = tl.Unmarshal(r, &t.FileHash)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) LiteServerGetMasterchainInfo(ctx context.Context) (res LiteServerMasterchainInfo, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x89b5e62e)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x85832881 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetMasterchainInfoExtRequest struct {
	Mode uint32
}

func (t LiteServerGetMasterchainInfoExtRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetMasterchainInfoExt(ctx context.Context, request LiteServerGetMasterchainInfoExtRequest) (res LiteServerMasterchainInfoExt, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetMasterchainInfoExtRequest `tlSumType:"70a671df"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa8cce0f5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

func (c *Client) LiteServerGetTime(ctx context.Context) (res LiteServerCurrentTime, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x16ad5a34)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xe953000d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

func (c *Client) LiteServerGetVersion(ctx context.Context) (res LiteServerVersion, err error) {
	payload := make([]byte, 4)
	binary.LittleEndian.PutUint32(payload, 0x232b940b)
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x5a0491e5 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockRequest struct {
	Id TonNodeBlockIdExt
}

func (t LiteServerGetBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlock(ctx context.Context, request LiteServerGetBlockRequest) (res LiteServerBlockData, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockRequest `tlSumType:"6377cf0d"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa574ed6c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetStateRequest struct {
	Id TonNodeBlockIdExt
}

func (t LiteServerGetStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetState(ctx context.Context, request LiteServerGetStateRequest) (res LiteServerBlockState, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetStateRequest `tlSumType:"ba6e2eb6"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xabaddc0c {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockHeaderRequest struct {
	Id   TonNodeBlockIdExt
	Mode uint32
}

func (t LiteServerGetBlockHeaderRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlockHeader(ctx context.Context, request LiteServerGetBlockHeaderRequest) (res LiteServerBlockHeader, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockHeaderRequest `tlSumType:"21ec069e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerSendMessageRequest struct {
	Body []byte
}

func (t LiteServerSendMessageRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Body)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerSendMessage(ctx context.Context, request LiteServerSendMessageRequest) (res LiteServerSendMsgStatus, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerSendMessageRequest `tlSumType:"690ad482"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x3950e597 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAccountStateRequest struct {
	Id      TonNodeBlockIdExt
	Account LiteServerAccountId
}

func (t LiteServerGetAccountStateRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetAccountState(ctx context.Context, request LiteServerGetAccountStateRequest) (res LiteServerAccountState, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAccountStateRequest `tlSumType:"6b890e25"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x7079c751 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerRunSmcMethodRequest struct {
	Mode     uint32
	Id       TonNodeBlockIdExt
	Account  LiteServerAccountId
	MethodId uint64 `json:",string"`
	Params   []byte
}

func (t LiteServerRunSmcMethodRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.MethodId)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Params)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerRunSmcMethod(ctx context.Context, request LiteServerRunSmcMethodRequest) (res LiteServerRunMethodResult, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerRunSmcMethodRequest `tlSumType:"5cc65dd2"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xa39a616b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardInfoRequest struct {
	Id        TonNodeBlockIdExt
	Workchain uint32
	Shard     uint64 `json:",string"`
	Exact     bool
}

func (t LiteServerGetShardInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Workchain)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Shard)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Exact)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetShardInfo(ctx context.Context, request LiteServerGetShardInfoRequest) (res LiteServerShardInfo, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardInfoRequest `tlSumType:"46a2f425"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x9fe6cd84 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetAllShardsInfoRequest struct {
	Id TonNodeBlockIdExt
}

func (t LiteServerGetAllShardsInfoRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetAllShardsInfo(ctx context.Context, request LiteServerGetAllShardsInfoRequest) (res LiteServerAllShardsInfo, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetAllShardsInfoRequest `tlSumType:"74d3fd6b"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x98fe72d {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetOneTransactionRequest struct {
	Id      TonNodeBlockIdExt
	Account LiteServerAccountId
	Lt      uint64 `json:",string"`
}

func (t LiteServerGetOneTransactionRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetOneTransaction(ctx context.Context, request LiteServerGetOneTransactionRequest) (res LiteServerTransactionInfo, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetOneTransactionRequest `tlSumType:"d40f24ea"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xedeed47 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetTransactionsRequest struct {
	Count   uint32
	Account LiteServerAccountId
	Lt      uint64 `json:",string"`
	Hash    tl.Int256
}

func (t LiteServerGetTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Account)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Lt)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Hash)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetTransactions(ctx context.Context, request LiteServerGetTransactionsRequest) (res LiteServerTransactionList, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetTransactionsRequest `tlSumType:"1c40e7a1"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x6f26c60b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerLookupBlockRequest struct {
	Mode  uint32
	Id    TonNodeBlockId
	Lt    *uint64 `json:",string"`
	Utime *uint32
}

func (t LiteServerLookupBlockRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>1)&1 == 1 {
		b, err = tl.Marshal(t.Lt)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.Utime)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerLookupBlock(ctx context.Context, request LiteServerLookupBlockRequest) (res LiteServerBlockHeader, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerLookupBlockRequest `tlSumType:"fac8f71e"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x752d8219 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerListBlockTransactionsRequest struct {
	Id    TonNodeBlockIdExt
	Mode  uint32
	Count uint32
	After *LiteServerTransactionId3
}

func (t LiteServerListBlockTransactionsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Count)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>7)&1 == 1 {
		b, err = tl.Marshal(t.After)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerListBlockTransactions(ctx context.Context, request LiteServerListBlockTransactionsRequest) (res LiteServerBlockTransactions, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerListBlockTransactionsRequest `tlSumType:"adfcc7da"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xbd8cad2b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetBlockProofRequest struct {
	Mode        uint32
	KnownBlock  TonNodeBlockIdExt
	TargetBlock *TonNodeBlockIdExt
}

func (t LiteServerGetBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.KnownBlock)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.TargetBlock)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetBlockProof(ctx context.Context, request LiteServerGetBlockProofRequest) (res LiteServerPartialBlockProof, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetBlockProofRequest `tlSumType:"8aea9c44"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x8ed0d2c1 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigAllRequest struct {
	Mode uint32
	Id   TonNodeBlockIdExt
}

func (t LiteServerGetConfigAllRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetConfigAll(ctx context.Context, request LiteServerGetConfigAllRequest) (res LiteServerConfigInfo, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigAllRequest `tlSumType:"911b26b7"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetConfigParamsRequest struct {
	Mode      uint32
	Id        TonNodeBlockIdExt
	ParamList []uint32
}

func (t LiteServerGetConfigParamsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.ParamList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetConfigParams(ctx context.Context, request LiteServerGetConfigParamsRequest) (res LiteServerConfigInfo, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetConfigParamsRequest `tlSumType:"2a111c19"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xae7b272f {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetValidatorStatsRequest struct {
	Mode          uint32
	Id            TonNodeBlockIdExt
	Limit         uint32
	StartAfter    *tl.Int256
	ModifiedAfter *uint32
}

func (t LiteServerGetValidatorStatsRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Mode)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	b, err = tl.Marshal(t.Limit)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	if (t.Mode>>0)&1 == 1 {
		b, err = tl.Marshal(t.StartAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	if (t.Mode>>2)&1 == 1 {
		b, err = tl.Marshal(t.ModifiedAfter)
		if err != nil {
			return nil, err
		}
		_, err = buf.Write(b)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetValidatorStats(ctx context.Context, request LiteServerGetValidatorStatsRequest) (res LiteServerValidatorStats, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetValidatorStatsRequest `tlSumType:"091a58bc"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0xb9f796d8 {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetLibrariesRequest struct {
	LibraryList []tl.Int256
}

func (t LiteServerGetLibrariesRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.LibraryList)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetLibraries(ctx context.Context, request LiteServerGetLibrariesRequest) (res LiteServerLibraryResult, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetLibrariesRequest `tlSumType:"d122b662"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x117ab96b {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}

type LiteServerGetShardBlockProofRequest struct {
	Id TonNodeBlockIdExt
}

func (t LiteServerGetShardBlockProofRequest) MarshalTL() ([]byte, error) {
	var (
		err error
		b   []byte
	)
	buf := new(bytes.Buffer)
	b, err = tl.Marshal(t.Id)
	if err != nil {
		return nil, err
	}
	_, err = buf.Write(b)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Client) LiteServerGetShardBlockProof(ctx context.Context, request LiteServerGetShardBlockProofRequest) (res LiteServerShardBlockProof, err error) {
	payload, err := tl.Marshal(struct {
		tl.SumType
		Req LiteServerGetShardBlockProofRequest `tlSumType:"4ca60350"`
	}{SumType: "Req", Req: request})
	if err != nil {
		return res, err
	}
	resp, err := c.liteServerRequest(ctx, payload)
	if err != nil {
		return res, err
	}
	if len(resp) < 4 {
		return res, fmt.Errorf("not enough bytes for tag")
	}
	tag := binary.LittleEndian.Uint32(resp[:4])
	if tag == 0xbba9e148 {
		var errRes LiteServerError
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &errRes)
		if err != nil {
			return res, err
		}
		return res, errRes
	}
	if tag == 0x1d62a07a {
		err = tl.Unmarshal(bytes.NewReader(resp[4:]), &res)
		return res, err
	}
	return res, fmt.Errorf("invalid tag")
}
